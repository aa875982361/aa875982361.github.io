<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>叶落林间</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="个人学习笔记，仅供本人复习">
<meta property="og:type" content="website">
<meta property="og:title" content="叶落林间">
<meta property="og:url" content="http://nisonfuture.cn/page/2/index.html">
<meta property="og:site_name" content="叶落林间">
<meta property="og:description" content="个人学习笔记，仅供本人复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="叶落林间">
<meta name="twitter:description" content="个人学习笔记，仅供本人复习">
  
    <link rel="alternate" href="/atom.xml" title="叶落林间" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">叶落林间</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">你只有非常努力，才能看起来毫不费力</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://nisonfuture.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-jsx简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/jsx简介/" class="article-date">
  <time datetime="2018-03-05T10:11:39.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/jsx简介/">jsx简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一种 JavaScript 的语法扩展。 我们推荐在 React 中使用 JSX 来描述用户界面。JSX 乍看起来可能比较像是模版语言，但事实上它完全是在 JavaScript 内部实现的。</p>
</blockquote>
<h3 id="在-JSX-中使用表达式"><a href="#在-JSX-中使用表达式" class="headerlink" title="在 JSX 中使用表达式"></a>在 JSX 中使用表达式</h3><pre><code>可以在jsx中插入函数 或变量
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function formatName(user) &#123;</span><br><span class="line">  return user.firstName + &apos; &apos; + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = &#123;</span><br><span class="line">  firstName: &apos;Harper&apos;,</span><br><span class="line">  lastName: &apos;Perez&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="JSX-本身其实也是一种表达式"><a href="#JSX-本身其实也是一种表达式" class="headerlink" title="JSX 本身其实也是一种表达式"></a>JSX 本身其实也是一种表达式</h3><blockquote>
<p>在编译之后呢，JSX 其实会被转化为普通的 JavaScript 对象。<br>这也就意味着，你其实可以在 if 或者 for 语句里使用 JSX，将它赋值给变量，当作参数传入，作为返回值都可以：</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getGreeting(user) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSX-属性"><a href="#JSX-属性" class="headerlink" title="JSX 属性"></a>JSX 属性</h3><p>可以使用引号来定义以字符串为值的属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;div tabIndex="0"&gt;&lt;/div&gt;;</span><br></pre></td></tr></table></figure>
<p>也可以使用大括号来定义以 JavaScript 表达式为值的属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>切记你使用了大括号包裹的 JavaScript 表达式时就不要再到外面套引号了。JSX 会将引号当中的内容识别为字符串而不是表达式。</p>
</blockquote>
<h3 id="JSX-嵌套"><a href="#JSX-嵌套" class="headerlink" title="JSX 嵌套"></a>JSX 嵌套</h3><p>如果 JSX 标签是闭合式的，那么你需要在结尾处用 /&gt;, 就好像 XML/HTML 一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="JSX-标签同样可以相互嵌套："><a href="#JSX-标签同样可以相互嵌套：" class="headerlink" title="JSX 标签同样可以相互嵌套："></a>JSX 标签同样可以相互嵌套：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告:<br>因为 JSX 的特性更接近 JavaScript 而不是 HTML , 所以 React DOM 使用 camelCase 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称。<br>例如，class 变成了 className，而 tabindex 则对应着 tabIndex.</p>
</blockquote>
<h3 id="JSX-防注入攻击"><a href="#JSX-防注入攻击" class="headerlink" title="JSX 防注入攻击"></a>JSX 防注入攻击</h3><p>React DOM 在渲染之前默认会 过滤 所有传入的值。它可以确保你的应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击。</p>
<h3 id="JSX-代表-Objects"><a href="#JSX-代表-Objects" class="headerlink" title="JSX 代表 Objects"></a>JSX 代表 Objects</h3><p>Babel 转译器会把 JSX 转换成一个名为 React.createElement() 的方法调用。</p>
<p>下面两种代码的作用是完全相同的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;<span class="selector-tag">h1</span> className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;className: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>React.createElement() 这个方法首先会进行一些避免bug的检查，之后会返回一个类似下面例子的对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 以下示例是简化过的（不代表在 React 源码中是这样）</span></span><br><span class="line">const element = &#123;</span><br><span class="line">  type: <span class="string">'h1'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'greeting'</span>,</span><br><span class="line">    children: <span class="string">'Hello, world'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样的对象被称为 “React 元素”。它代表所有你在屏幕上看到的东西。React 通过读取这些对象来构建 DOM 并保持数据内容一致。</p>
<blockquote>
<p>Tip:<br>如果你是在使用本地编辑器编写 JSX 代码的话，推荐你去装一个支持 JSX 高亮的插件，这样更方便之后的开发学习。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nisonfuture.cn/2018/03/05/jsx简介/" data-id="cjelltual0006i4ug8wy0jeuy" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-条件渲染" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/条件渲染/" class="article-date">
  <time datetime="2018-03-05T10:11:39.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/条件渲染/">条件渲染</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后还可以根据应用的状态变化只渲染其中的一部分。</p>
<p>React 中的条件渲染和 JavaScript 中的一致，使用 JavaScript 操作符 if 或条件运算符来创建表示当前状态的元素，然后让 React 根据它们来更新 UI。</p>
<p>先来看两个组件:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将创建一个 Greeting 组件，它会根据用户是否登录来显示其中之一：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return <span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">  // Try changing to isLoggedIn=&#123;true&#125;:</span></span><br><span class="line">  &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;,</span><br><span class="line">  document.getElementById('root')</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h2><p>可以使用变量来储存元素。它可以帮助你有条件的渲染组件的一部分，而输出的其他部分不会更改。</p>
<p>再来看两个新组件分别代表注销和登录：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">      Login</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function LogoutButton(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">      Logout</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下面的例子中，我们将要创建一个名为 LoginControl 的有状态的组件。</p>
<p>它会根据当前的状态来渲染\<loginbutton> 或\<logoutbutton>，它也将渲染前面例子中的 \<greeting>。</greeting></logoutbutton></loginbutton></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginControl</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleLoginClick = <span class="keyword">this</span>.handleLoginClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleLogoutClick = <span class="keyword">this</span>.handleLogoutClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">isLoggedIn</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLoginClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">isLoggedIn</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLogoutClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">isLoggedIn</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> button = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">      button = <span class="xml"><span class="tag">&lt;<span class="name">LogoutButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLogoutClick&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125; else &#123;</span></span><br><span class="line">      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class="line">        &#123;button&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;LoginControl /&gt;,</span><br><span class="line">  document.getElementById('root')</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>声明变量并使用 if 语句是条件渲染组件的不错的方式，但有时你也想使用更简洁的语法，在 JSX 中有如下几种方法。</p>
<h2 id="与运算符-amp-amp"><a href="#与运算符-amp-amp" class="headerlink" title="与运算符 &amp;&amp;"></a>与运算符 &amp;&amp;</h2><p>你可以通过用花括号包裹代码在 JSX 中嵌入任何表达式 ，也包括 JavaScript 的逻辑与 &amp;&amp;，它可以方便地条件渲染一个元素。</p>
<p>理解：通过第一个条件成立 才有第二个条件的运行 第一个条件不满足，则不执行第二个条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Mailbox(props) &#123;</span><br><span class="line">  const unreadMessages = props.unreadMessages;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      &#123;unreadMessages.length &gt; 0 &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const messages = [&apos;React&apos;, &apos;Re: React&apos;, &apos;Re:Re: React&apos;];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>之所以能这样做，是因为在 JavaScript 中，true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。</p>
<p>因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。</p>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>条件渲染的另一种方法是使用 JavaScript 的条件运算符 condition ? true : false。</p>
<p>在下面的例子中，我们用它来有条件的渲染一小段文本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      The user is &lt;b&gt;&#123;isLoggedIn ? <span class="string">'currently'</span> : <span class="string">'not'</span>&#125;&lt;<span class="regexp">/b&gt; loggined in.</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样可以用在较大的表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLoggedIn ? (</span><br><span class="line">        &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>像在 JavaScript 中一样，你可以根据团队的习惯选择更易读的方式。还要记住如果条件变得过于复杂，可能就是<strong>提取组件</strong>的好时机了。</p>
<h2 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h2><p>在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。</p>
<p>在下面的例子中，<warningbanner> 根据属性 warn 的值条件渲染。如果 warn 的值是 false，则组件不会渲染：</warningbanner></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"warning"</span>&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Page extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123;showWarning: true&#125;</span></span><br><span class="line"><span class="regexp">    this.handleToggleClick = this.handleToggleClick.bind(this);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleToggleClick() &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(prevState =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">      showWarning: !prevState.showWarning</span></span><br><span class="line"><span class="regexp">    &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.showWarning ? <span class="string">'Hide'</span> : <span class="string">'Show'</span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Page /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>组件的 render 方法返回 null 并<strong>不会影响该组件生命周期方法的回调</strong>。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nisonfuture.cn/2018/03/05/条件渲染/" data-id="cjelltub2000ti4ugk3cpdq5q" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-React 理念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/React 理念/" class="article-date">
  <time datetime="2018-03-05T10:11:39.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/React 理念/">React 理念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在我们的理念中，React 最初的目的是使用 JavaScript 创建大型的，快速响应的网络应用。它在我们的 Facebook 和 Instagram 中已经实践的非常好了。</p>
<p>React的众多优点之一是它让你在编写代码的时候同时也在思考你的应用。在这篇文档中，我们会带你使用 React 一起创建一个可搜索的产品数据表格，并向你展示我们的思考过程。</p>
<h2 id="从模拟页面开始"><a href="#从模拟页面开始" class="headerlink" title="从模拟页面开始"></a>从模拟页面开始</h2><p>想象我们已经有一个 JSON 接口和一个设计师给我们的原型图。原型图像下面这样：<br><img src="https://doc.react-china.org/static/thinking-in-react-mock-1071fbcc9eed01fddc115b41e193ec11-4dd91.png" alt="enter description here"></p>
<p>  我们的 JSON 接口返回类似下面的数据：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"&#125;,</span><br><span class="line">  &#123;category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"&#125;,</span><br><span class="line">  &#123;category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"&#125;,</span><br><span class="line">  &#123;category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"&#125;,</span><br><span class="line">  &#123;category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"&#125;,</span><br><span class="line">  &#123;category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h2 id="第一步：把-UI-划分出组件层级"><a href="#第一步：把-UI-划分出组件层级" class="headerlink" title="第一步：把 UI 划分出组件层级"></a>第一步：把 UI 划分出组件层级</h2><p>第一件你要做的事情是用方框划分出每一个组件(和子组件)并给他们命名。如果你和设计师一起工作，他们可能已经完成了这些，所以去和他们聊聊吧！他们的 Photoshop 图层名称也许就是你的 React 组件名称！</p>
<p>但你如何知道哪一部分应该成为一个组件？想想在编写代码时你在什么情况下需要新建一个函数或对象，思考方式是一样的。例如 单一功能原则，在理想状况下，一个组件应该只做一件事情。如果这个组件功能不断丰富，它应该被分成更小的组件。</p>
<p>既然你经常向用户展示 JSON 数据模型，你会发现，如果你的模型构建正确，你的 UI (以及你的组件结构)会被很好的映射。这是因为 UI 和数据模型往往遵循着相同的信息架构，这意味着将 UI 划分成组件的工作往往是很容易的。只要把它划分成能准确表示你数据模型的一部分的组件就可以。</p>
<p><img src="https://doc.react-china.org/static/thinking-in-react-components-eb8bda25806a89ebdc838813bdfa3601-82965.png" alt="enter description here"></p>
<p>  在这里你会看到，我们的简单应用中有5个组件。我们把每个组件展示的数据用斜体表示。</p>
<ul>
<li>FilterableProductTable (橙色): 包含了整个例子<ul>
<li>SearchBar (蓝色): 接受所有的用户输入</li>
<li>ProductTable (绿色): 根据用户输入过滤并展示数据集合</li>
<li>ProductCategoryRow (绿松石色): 展示每个分类的标题</li>
<li>ProductRow (红色): 用行来展示每个产品</li>
</ul>
</li>
</ul>
<p>如果你查看 ProductTable，你会发现表头(包含 Name 和 Price 标签)并没有作为一个组件。这是一个偏好问题，选择哪种方式目前还存在争议。在这个例子中，我们把它作为 ProductTable 的一部分，因为它是渲染数据集合的一部分，而渲染数据集合是 ProductTable 的职责。然而，如果头部变得更加复杂(也就是，如果我们添加了排序功能)，它就有足够的理由成为一个单独的 ProductTableHeader 组件。</p>
<p>现在我们已经确定了原型图中的组件，让我们把它们整理成层级结构。这很容易。原型图中的子组件在层级结构中应该作为子节点。<br>FilterableProductTable</p>
<ul>
<li>SearchBar</li>
<li><p>ProductTable<br> 1  ProductCategoryRow<br>  2  ProductRow</p>
<h2 id="第二步：用-React-创建一个静态版本"><a href="#第二步：用-React-创建一个静态版本" class="headerlink" title="第二步：用 React 创建一个静态版本"></a>第二步：用 React 创建一个静态版本</h2><p>现在有了组件层级，是时候去实现你的应用了。最简单的方式是先创建一个静态版本：传入数据模型，渲染 UI 但没有任何交互。最好把这些过程解耦，因为创建一个静态版本更多需要的是码代码，不太需要逻辑思考，而添加交互则更多需要的是逻辑思考，不是码代码。我们会看看为什么是这样的。</p>
</li>
</ul>
<p>要构建一个用于呈现数据模型的静态版本的应用程序，你需要创建能够复用其他组件的组件，并通过 props 来传递数据。props 是一种从父级向子级传递数据的方法。如果你熟悉 state 的概念， 在创建静态版本的时候不要使用 state。State 只在交互的时候使用，即随时间变化的数据。由于这是静态版本的应用，你不需要使用它。</p>
<p>你可以自顶向下或者自底向上构建应用。也就是，你可以从层级最高的组件开始构建(即 FilterableProductTable开始)或层级最低的组件开始构建(ProductRow)。在较为简单的例子中，通常自顶向下更容易，而在较大的项目中，自底向上会更容易并且在你构建的时候有利于编写测试。</p>
<p>在这步的最后，你会拥有一个用于呈现数据模型的可重用组件库。这些组件只会有 render() 方法，因为这只是你的应用的静态版本。层级最高的组件(FilterableProductTable)会把数据模型作为 prop 传入。如果你改变你的基础数据模型并且再次调用 ReactDOM.render()， UI 会更新。很容易看到你的 UI 是如何更新的，哪里进行了更新。因为没有什么复杂的事情发生。React 的<strong>单向数据流</strong>(也叫作单向绑定)保证了一切是模块化并且是快速的。</p>
<h2 id="一个小插曲：Props-VS-State"><a href="#一个小插曲：Props-VS-State" class="headerlink" title="一个小插曲：Props VS State"></a>一个小插曲：Props VS State</h2><p>  在 React 中有两种数据模型：props 和 state。理解两者的差别是很重要的</p>
<h2 id="第三步：定义-UI-状态的最小-但完整-表示"><a href="#第三步：定义-UI-状态的最小-但完整-表示" class="headerlink" title="第三步：定义 UI 状态的最小(但完整)表示"></a>第三步：定义 UI 状态的最小(但完整)表示</h2><p>  为了使你的 UI 交互，你需要能够触发对底层数据模型的更改。React 使用 state，让这变的更容易。</p>
<p>为了正确构建你的应用，首先你需要考虑你的应用所需要的最小可变状态集。要点是 DRY：不要重复(Don’t Repeat Yourself)。找出应用程序的绝对最小表示并计算你所需要的其他任何请求。例如，如果你正在创建一个 TODO 列表，只要保存一个包含 TODO 事项的数组；不要为计数保留一个单独的状态变量。相反，当你想要渲染 TODO 计数时，只需要使用 TODO 数组的长度就可以了。</p>
<p>想想我们的实例应用中所有数据。我们有：</p>
<ul>
<li>原产品列表</li>
<li>用户输入的搜索文本</li>
<li>复选框的值</li>
<li>产品的筛选列表</li>
</ul>
<p>让我们来看看每一条，找出哪一个是 state。每个数据只要考虑三个问题：</p>
<ul>
<li>它是通过 props 从父级传来的吗？如果是，他可能不是 state。</li>
<li>它随着时间推移不变吗？如果是，它可能不是 state。</li>
<li>你能够根据组件中任何其他的 state 或 props 把它计算出来吗？如果是，它不是 state。<br>原产品列表被作为 props 传入，所以它不是 state。搜索文本和复选框似乎是 state，因为它们随时间改变并且不能由其他任何值计算出来。最后，产品的筛选列表不是 state，因为它可以通过将原始产品列表与搜索文本和复选框的值组合计算出来。</li>
</ul>
<p>最后，我们的 state 有：</p>
<ul>
<li>用户输入的搜索文本</li>
<li>复选框的值<h2 id="第四步：确定你的-State-应该位于哪里"><a href="#第四步：确定你的-State-应该位于哪里" class="headerlink" title="第四步：确定你的 State 应该位于哪里"></a>第四步：确定你的 State 应该位于哪里</h2>好的，现在我们确定了应用 state 的最小集合。接下来，我们需要确定哪个组件会改变，或拥有这个 state。</li>
</ul>
<p>记住：React 中的数据流是单向的，并在组件层次结构中向下传递。一开始我们可能不是很清楚哪个组件应该拥有哪个 state。在新手理解上这通常是最富有挑战性的部分，所以按照下面的步骤来辨别：</p>
<p>对你应用的每一个 state：</p>
<ul>
<li>确定每一个需要这个 state 来渲染的组件。</li>
<li>找到一个公共所有者组件(一个在层级上高于所有其他需要这个 state 的组件的组件)</li>
<li>这个公共所有者组件或另一个层级更高的组件应该拥有这个 state。</li>
<li>如果你没有找到可以拥有这个 state 的组件，创建一个仅用来保存状态的组件并把它加入比这个公共所有者组件层级更高的地方。</li>
<li>让我们用这个策略分析我们的应用：</li>
</ul>
<p>ProductTable 需要根据 state 过滤产品列表，SearchBar 需要展示搜索文本和复选框状态。<br>公共所有者组件是 FilterableProductTable。<br>筛选文本和复选框的值应该放在 FilterableProductTable。<br>很酷，所以我们决定把 state 放在 FilterableProductTable。首先，为 FilterableProductTable 的 constructor 添加一个实例属性 this.state = {filterText: ‘’, inStockOnly: false} 来表示我们应用的初始状态。接下来，把 filterText 和 inStockOnly 作为 prop 传入 ProductTable 和 SearchBar。最后在 ProductTable 中使用这些 props 来筛选每行产品信息，在 SearchBar 中设置表单域的值。</p>
<p>现在你能够看到你的应用是如何运作的了：设置 filterText 的值为 ball 并刷新你的应用。你会看到数据表格正确的更新了。</p>
<h2 id="第五步：添加反向数据流"><a href="#第五步：添加反向数据流" class="headerlink" title="第五步：添加反向数据流"></a>第五步：添加反向数据流</h2><p>到目前为止，我们已经创建了一个可以正确渲染的应用程序，它的数据在层级中通过函数的 props 和 state 向下流动。现在是时候支持其他方式的数据流了：层级结构中最底层的表单组件需要去更新在 FilterableProductTable 中的 state。</p>
<p>React 的数据流很明显，让你可以很轻松的了解你的程序是如何运行的，但相较于传统的双向绑定，它的代码量会稍微多一点。</p>
<p>在当前版本的示例中，如果你试图键入或选中复选框，你会发现 React 会忽略你的输入。这是故意的，因为我们把 input 的 value 属性设置为一直等于从 FilterableProductTable 传入的 state.</p>
<p>让我们想想我们想要做什么。我们想确保每当用户更改表单时，我们更新状态来反应用户输入。因为组件应该只更新自己的状态， FilterableProductTable 会将一个回调函数传递给 SearchBar ，每当应该更新状态时，它就会触发。我们可以使用输入上的 onChange 事件来调用它。FilterableProductTable 传入的回调函数会调用 setState()，这时应用程序会被更新。</p>
<p>虽然这听起来很复杂，但它只是几行代码的问题。而且，你可以清楚地看出你的应用中数据是如何流动的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nisonfuture.cn/2018/03/05/React 理念/" data-id="cjelltuai0004i4uget3h0c6u" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-状态提升" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/状态提升/" class="article-date">
  <time datetime="2018-03-05T10:11:39.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/状态提升/">状态提升</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用 react 经常会遇到几个组件需要共用状态数据的情况。这种情况下，我们最好将这部分<strong>共享的状态</strong>提升至他们最近的父组件当中进行管理。我们来看一下具体如何操作吧。</p>
<p>这部分内容当中，我们会创建一个温度计算器来计算水是否会在给定的温度下烧开。</p>
<p>开始呢，我们先创建一个名为 BoilingVerdict 的组件。它会接受 celsius 这个温度变量作为它的 prop 属性，最后根据温度判断返回内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function BoilingVerdict(props) &#123;</span><br><span class="line">  if (props.celsius &gt;= 100) &#123;</span><br><span class="line">    return &lt;p&gt;水会烧开&lt;/p&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;p&gt;水不会烧开&lt;/p&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们写一个名为 Calculator 的组件。它会渲染一个 \<input> 来接受用户输入，然后将输入的温度值保存在 this.state.temperature 当中。</p>
<p>之后呢，它会根据输入的值渲染出 BoilingVerdict 组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Calculator extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.state.temperature;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;输入一个摄氏温度&lt;/legend&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          value=&#123;temperature&#125;</span><br><span class="line">          onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;BoilingVerdict</span><br><span class="line">          celsius=&#123;parseFloat(temperature)&#125; /&gt;</span><br><span class="line"> </span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们有了一个新的需求，在提供摄氏度输入的基础之上，再提供一个华氏温度输入，并且它们能保持同步。</p>
<p>我们可以通过从 Calculator 组件中抽离一个 TemperatureInput 组件出来。我们也会给它添加一个值为 c 或 f 的表示温度单位的 scale 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const scaleNames = &#123;</span><br><span class="line">  c: &apos;Celsius&apos;,</span><br><span class="line">  f: &apos;Fahrenheit&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.state.temperature;</span><br><span class="line">    const scale = this.props.scale;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt;</span><br><span class="line">        &lt;input value=&#123;temperature&#125;</span><br><span class="line">               onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在有了两个输入框，但是当你在其中一个输入时，另一个并不会更新。这显然是不符合我们的需求的。</p>
<p>另外，我们此时也不能从 Calculator 组件中展示 BoilingVerdict 的渲染结果。因为现在表示温度的状态数据只存在于 TemperatureInput 组件当中。</p>
<h2 id="写出转换函数"><a href="#写出转换函数" class="headerlink" title="写出转换函数"></a>写出转换函数</h2><p>首先，我们写两个可以将摄氏度和华氏度互相转换的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function toCelsius(fahrenheit) &#123;</span><br><span class="line">  return (fahrenheit - 32) * 5 / 9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toFahrenheit(celsius) &#123;</span><br><span class="line">  return (celsius * 9 / 5) + 32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数只是单纯转换数字。我们还需要另外一个函数，它接受两个参数，第一个接受字符串 temperature 变量，第二个参数则是上面编写的单位转换函数。最后会返回一个字符串。我们会使用它来根据一个输入框的输入计算出另一个输入框的值。</p>
<p>我们最后取到输出的小数点后三位，而 temperature 输入不合法的时候，这个函数则会返回空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function tryConvert(temperature, convert) &#123;</span><br><span class="line">  const input = parseFloat(temperature);</span><br><span class="line">  if (Number.isNaN(input)) &#123;</span><br><span class="line">    return &apos;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  const output = convert(input);</span><br><span class="line">  const rounded = Math.round(output * 1000) / 1000;</span><br><span class="line">  return rounded.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举两个例子，tryConvert(‘abc’, toCelsius) 会返回空字符串，而 tryConvert(‘10.22’, toFahrenheit) 会返回 ‘50.396’。</p>
<h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>到这一步为止，两个TemperatureInput组件都是在自己的 state 中独立保存数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.state.temperature;</span><br></pre></td></tr></table></figure>
<p>但是，我们想要的是这两个输入能保持同步。当我们更新摄氏输入（Celsius）时，华氏度（Fahrenheit ）这个框应该能显示转换后的的温度数值，反之亦然。</p>
<p>在React中，状态分享是通过将state数据提升至离需要这些数据的组件最近的父组件来完成的。这就是所谓的<strong>状态提升</strong>。我们会将 TemperatureInput 组件自身保存的 state 移到 Calculator 中。</p>
<p>如果 Calculator 组件拥有了提升上来共享的状态数据，那它就会成为两个温度输入组件的“数据源”。它会传递给下面温度输入组件一致的数据。由于两个 TemperatureInput 温度组件的props属性都是来源于共同的父组件 Calculator，它们的数据也会保持同步。</p>
<p>让我们一步一步来分析如何操作。</p>
<p>首先，我们在 TemperatureInput 组件中将 this.state.temperature 替换为 this.props.temperature 。从现在开始，我们假定 this.props.temperature 属性已经存在了，不过之后仍然需要将数据从 Calculator 组件中传进去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    // 之前的代码: const temperature = this.state.temperature;</span><br><span class="line">    const temperature = this.props.temperature;</span><br></pre></td></tr></table></figure>
<p>我们首先知道props是只读的 这么一个事实。而之前temperature变量是被保存在其自身的 state 中的，TemperatureInput 组件只需要调用 this.setState() 就能改变它。但现在，temperature 是作为 prop 从<strong>父组件传递下来</strong>的，TemperatureInput 组件是<strong>没有控制权</strong>的。</p>
<p>在React中，这个问题通常是通过让组件“<strong>受控</strong>”来解决。就像 \<input> 能够接受 value 和 onChange 这两个prop属性值，自定义组件 TemperatureInput 也能接受来自 Calculator 父组件的 temperature 变量和 onTemperatureChange 方法作为props属性值。</p>
<p>做完这些，当 TemperatureInput 组件更新它的温度数值时，就会调用 this.props.onTemperatureChange 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange(e) &#123;</span><br><span class="line">  // 之前的代码: this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  this.props.onTemperatureChange(e.target.value);</span><br></pre></td></tr></table></figure>
<p>需要指出的是，我们现在定义的 temperature 和 onTemperatureChange 这些prop属性的命名没有特殊含义，我们也可以起个其他任何的名字，像是value和onChange这些只是命名习惯罢了。</p>
<p>onTemperatureChange 和 temperature 两个 props 属性均由父组件 Calculator 提供。<strong>父组件可以通过自身的方法来响应状态数据的改变</strong>，从而使用新的值来重新渲染两个输入框组件。不过我们先放着，最后再来修改它。</p>
<p>在我们改写 Calculator 组件之前，我们先花点时间总结下 TemperatureInput 组件的改变。</p>
<ol>
<li>我们将其自身的 state 从组件中移除，</li>
<li>使用 this.props.temperature 替代 this.state.temperature ，</li>
<li>当我们想要响应数据改变时，使用父组件提供的 this.props.onTemperatureChange() 而不是this.setState() 方法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.props.temperature;</span><br><span class="line">    const scale = this.props.scale;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;在&#123;scaleNames[scale]&#125;:中输入温度数值&lt;/legend&gt;</span><br><span class="line">        &lt;input value=&#123;temperature&#125;</span><br><span class="line">               onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们来看看 Calculator 组件。</p>
<p>我们将会在它的 state 中存储之前输入框组件的 temperature 和 scale 值，这是从输入框组件中“提升”上来的 state，它将会成为两个输入框组件的“数据源”。这是我们所需要的能够重新渲染并且表示两个不同输入组件的最基本的数据。</p>
<p>举个例子，假如我们在摄氏度输入框中输入37，那么 Calculator 的 state 就是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  temperature: <span class="string">'37'</span>,</span><br><span class="line">  scale: <span class="string">'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们之后在华氏度输入框输入212，那么 Calculator 的状态数据就会是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  temperature: &apos;212&apos;,</span><br><span class="line">  scale: &apos;f&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们可以一起保存两个输入的值，但这么做似乎没有必要。保存最近 改变的值和所需标识的温标单位就足够了。我们可以只需基于当前的 temperature 和 scale 计算出另一个输入框中的值。</p>
<p>现在这两个输入框中的值能保持同步了，因为它们使用的是通过同一个 state 计算出来的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Calculator extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);</span><br><span class="line">    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;, scale: &apos;c&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleCelsiusChange(temperature) &#123;</span><br><span class="line">    this.setState(&#123;scale: &apos;c&apos;, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleFahrenheitChange(temperature) &#123;</span><br><span class="line">    this.setState(&#123;scale: &apos;f&apos;, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const scale = this.state.scale;</span><br><span class="line">    const temperature = this.state.temperature;</span><br><span class="line">    const celsius = scale === &apos;f&apos; ? tryConvert(temperature, toCelsius) : temperature;</span><br><span class="line">    const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature, toFahrenheit) : temperature;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=&quot;c&quot;</span><br><span class="line">          temperature=&#123;celsius&#125;</span><br><span class="line">          onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=&quot;f&quot;</span><br><span class="line">          temperature=&#123;fahrenheit&#125;</span><br><span class="line">          onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;BoilingVerdict</span><br><span class="line">          celsius=&#123;parseFloat(celsius)&#125; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，无论你编辑哪一个输入框，Calculator 组件中 this.state.temperature 和 this.state.scale 都会更新。其中之一的输入框得到用户原样输入的值，另一个输入框总是显示基于这个值计算出的结果。</p>
<p>让我们梳理下编辑输入框时所发生的一系列活动：</p>
<ol>
<li>React在DOM原生组件<input>上调用指定的onChange函数。在本例中，指的是TemperatureInput组件上的handleChange函数。</li>
<li>TemperatureInput组件的handleChange函数会在值发生变化时调用this.props.onTemperatureChange()函数。这些props属性，像onTemperatureChange都是由父组件Calculator提供的。</li>
<li>当最开始渲染时，Calculator组件把内部的handleCelsiusChange方法指定给摄氏输入组件TemperatureInput的onTemperatureChange方法，并且把handleFahrenheitChange方法指定给华氏输入组件TemperatureInput的onTemperatureChange。两个Calculator内部的方法都会在相应输入框被编辑时被调用。</li>
<li>在这些方法内部，Calculator组件会让React使用编辑输入的新值和当前输入框的温标来调用this.setState()方法来重渲染自身。</li>
<li>React会调用Calculator组件的render方法来识别UI界面的样子。基于当前温度和温标，两个输入框的值会被重新计算。温度转换就是在这里被执行的。<br>接着React会使用Calculator指定的新props来分别调用TemperatureInput组件.React也会识别出子组件的UI界面。</li>
<li>React DOM 会更新DOM来匹配对应的值。我们编辑的输入框获取新值，而另一个输入框则更新经过转换的温度值。<br>一切更新都是经过同样的步骤，因而输入框能保持同步的。</li>
</ol>
<h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><p>在React应用中，对应任何可变数据理应只有一个<strong>单一“数据源”</strong>。通常，状态都是首先添加在需要渲染数据的组件中。此时，如果另一个组件也需要这些数据，你可以将数据提升至离它们最近的父组件中。你应该在应用中保持 自上而下的数据流，而不是尝试在不同组件中同步状态。</p>
<p><strong>状态提升比双向绑定</strong>方式要写更多的“模版代码”，但带来的好处是，你也可以更快地寻找和定位bug的工作。因为哪个组件保有状态数据，也只有它自己能够操作这些数据，发生bug的范围就被大大地减小了。此外，你也可以使用自定义逻辑来拒绝或者更改用户的输入。</p>
<p>如果某些数据可以由props或者state提供，那么它很有可能不应该在state中出现。举个例子，我们仅仅保存最新的编辑过的temperature和scale值，而不是同时保存 celsiusValue 和 fahrenheitValue 。另一个输入框中的值总是可以在 render() 函数中由这些保存的数据计算出来。这样我们可以根据同一个用户输入精准计算出两个需要使用的数据。</p>
<p>当你在开发UI界面遇到问题时，你可以使用 React 开发者工具来检查props属性，并且可以点击查看组件树，直到你找到负责目前状态更新的组件。这能让你到追踪到产生 bug 的源头。<br><img src="https://doc.react-china.org/react-devtools-state-ef94afc3447d75cdc245c77efb0d63be.gif" alt="enter description here"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nisonfuture.cn/2018/03/05/状态提升/" data-id="cjelltub60010i4ug6mcs4xzb" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-组合 vs 继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/组合 vs 继承/" class="article-date">
  <time datetime="2018-03-05T10:11:39.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/组合 vs 继承/">组合 vs 继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>React 具有强大的组合模型，我们建议使用组合而不是继承来复用组件之间的代码。</p>
<p>在本节中，我们将围绕几个 React 新手经常使用继承解决的问题，我们将展示如果用组合来解决它们。</p>
<h2 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h2><p>一些组件不能提前知道它们的子组件是什么。这对于 Sidebar 或 Dialog 这类通用容器尤其常见。</p>
<p>我们建议这些组件使用 children 属性<strong>将子元素直接传递</strong>到输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function FancyBorder(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#123;&apos;FancyBorder FancyBorder-&apos; + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做还允许其他组件通过<strong>嵌套 JSX 来传递子组件</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color=&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className=&quot;Dialog-title&quot;&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=&quot;Dialog-message&quot;&gt;</span><br><span class="line">        Thank you for visiting our spacecraft!</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><fancyborder> JSX 标签内的任何内容都将通过 children 属性传入 FancyBorder。由于 FancyBorder 在一个 <div> 内渲染了 {props.children}，所以被传递的所有元素都会出现在最终输出中。</div></fancyborder></p>
<p>虽然不太常见，但有时你可能需要在组件中有多个入口，这种情况下你可以使用自己约定的属性而不是 children：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function SplitPane(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;SplitPane&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;SplitPane-left&quot;&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;SplitPane-right&quot;&gt;</span><br><span class="line">        &#123;props.right&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;SplitPane</span><br><span class="line">      left=&#123;</span><br><span class="line">        &lt;Contacts /&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right=&#123;</span><br><span class="line">        &lt;Chat /&gt;</span><br><span class="line">      &#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似 <contacts> 和 <chat> 这样的 React 元素都是对象，所以你可以像任何其他元素一样传递它们。</chat></contacts></p>
<h2 id="特殊实例"><a href="#特殊实例" class="headerlink" title="特殊实例"></a>特殊实例</h2><p>有时我们认为组件是其他组件的特殊实例。例如，我们会说 WelcomeDialog 是 Dialog 的特殊实例。</p>
<p>在 React 中，这也是通过组合来实现的，通过配置属性用较特殊的组件来渲染较通用的组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Dialog(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color=&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className=&quot;Dialog-title&quot;&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=&quot;Dialog-message&quot;&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Dialog</span><br><span class="line">      title=&quot;Welcome&quot;</span><br><span class="line">      message=&quot;Thank you for visiting our spacecraft!&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>组合对于定义为类的组件同样适用：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function Dialog(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color=&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className=&quot;Dialog-title&quot;&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=&quot;Dialog-message&quot;&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SignUpDialog extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSignUp = this.handleSignUp.bind(this);</span><br><span class="line">    this.state = &#123;login: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Dialog title=&quot;Mars Exploration Program&quot;</span><br><span class="line">              message=&quot;How should we refer to you?&quot;&gt;</span><br><span class="line">        &lt;input value=&#123;this.state.login&#125;</span><br><span class="line">               onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;this.handleSignUp&#125;&gt;</span><br><span class="line">          Sign Me Up!</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/Dialog&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;login: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSignUp() &#123;</span><br><span class="line">    alert(`Welcome aboard, $&#123;this.state.login&#125;!`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那么继承呢？"><a href="#那么继承呢？" class="headerlink" title="那么继承呢？"></a>那么继承呢？</h2><p>在 Facebook 网站上，我们的 React 使用了数以千计的组件，然而却还未发现任何需要推荐你使用继承的情况。</p>
<p>属性和组合为你提供了以清晰和安全的方式自定义组件的样式和行为所需的所有灵活性。请记住，组件可以接受任意元素，包括基本数据类型、React 元素或函数。</p>
<p>如果要在组件之间复用 UI 无关的功能，我们建议将其提取到单独的 JavaScript 模块中。这样可以在不对组件进行扩展的前提下导入并使用该函数、对象或类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nisonfuture.cn/2018/03/05/组合 vs 继承/" data-id="cjelltubd001ei4ugtvviz4bh" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-组件 &amp; Props" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/组件 & Props/" class="article-date">
  <time datetime="2018-03-05T10:11:39.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/组件 & Props/">组件 &amp; Props</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。</p>
<p>组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。</p>
<h2 id="函数定义-类定义组件"><a href="#函数定义-类定义组件" class="headerlink" title="函数定义/类定义组件"></a>函数定义/类定义组件</h2><p>定义一个组件最简单的方式是使用JavaScript函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">//这样可以直接使用 &lt;Welcome /&gt;这个标签</span><br></pre></td></tr></table></figure>
<p>也可以使用es6的规范来声明一个组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h2><p>当React遇到的元素是用户自定义的组件，它会将JSX属性作为单个对象传递给该组件,这个对象称之为“props”。<br>例如,这段代码会在页面上渲染出”Hello,Sara”:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const element = &lt;Welcome name="Sara" /&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这个例子中发生了什么：</p>
<ol>
<li>我们对<welcome name="Sara">元素调用了ReactDOM.render()方法。</welcome></li>
<li>React将{name: ‘Sara’}作为props传入并调用Welcome组件。</li>
<li>Welcome组件将\<h1>Hello, Sara\</h1>元素作为结果返回。</li>
<li>React DOM将DOM更新为\<h1>Hello, Sara\</h1>。<blockquote>
<p>警告:<br>组件名称必须以<strong>大写字母开头</strong>。<br>例如，\<div> 表示一个DOM标签，但 \<welcome> 表示一个组件，并且在使用该组件时你必须定义或引入它。</welcome></div></p>
</blockquote>
<h2 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h2>组件可以在它的输出中引用其它组件，这就可以让我们用同一组件来抽象出任意层次的细节。在React应用中，按钮、表单、对话框、整个屏幕的内容等，这些通常都被表示为组件。</li>
</ol>
<p>例如，我们可以创建一个App组件，用来多次渲染Welcome组件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Sara"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Cahal"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Edite"</span> /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>通常，一个新的React应用程序的<strong>顶部是一个App组件</strong>。但是，如果要将React集成到现有应用程序中，则可以从下而上使用像Button这样的小组件作为开始，并逐渐运用到视图层的顶部。</p>
<blockquote>
<p>警告:<br>组件的<strong>返回值只能有一个根元素</strong>。这也是我们要用一个\<div>来包裹所有\<welcome>元素的原因。</welcome></div></p>
</blockquote>
<h2 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h2><p>在写组件的时候 如果组件复杂的话，很难被重用，所以在写组件的时候需要将一些组件提取出来，提高重用性。下面是一个复杂的组件：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Comment(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;<span class="selector-tag">div</span> className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">div</span> className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">img</span> className=<span class="string">"Avatar"</span></span><br><span class="line">          src=&#123;props<span class="selector-class">.author</span><span class="selector-class">.avatarUrl</span>&#125;</span><br><span class="line">          alt=&#123;props<span class="selector-class">.author</span><span class="selector-class">.name</span>&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">          &#123;props<span class="selector-class">.author</span><span class="selector-class">.name</span>&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;<span class="selector-tag">div</span> className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;<span class="selector-tag">div</span> className=<span class="string">"Comment-date"</span>&gt;</span><br><span class="line">        &#123;formatDate(props.date)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个组件接收author(对象)、text(字符串)、以及date(Date对象)作为props, 用来描述一个社交媒体网站上的评论。<br>这个组件由于<strong>嵌套</strong>，变得难以被修改，可复用的部分也难以被复用（例如）。所以可以从这个组件中提取出一些小组件。</p>
<p>首先，我们来提取Avatar组件：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Avatar(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;<span class="selector-tag">img</span> className=<span class="string">"Avatar"</span></span><br><span class="line">      src=&#123;props<span class="selector-class">.user</span><span class="selector-class">.avatarUrl</span>&#125;</span><br><span class="line">      alt=&#123;props<span class="selector-class">.user</span><span class="selector-class">.name</span>&#125;</span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Avatar作为Comment的内部组件，不需要知道是否被渲染。因此我们将author改为一个更通用的名字user。</p>
<p>我们建议<strong>从组件自身的角度来命名props</strong>，而不是根据使用组件的上下文命名。</p>
<p>现在我们可以对Comment组件做一些小小的调整：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Comment(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;<span class="selector-tag">div</span> className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">div</span> className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;Avatar user=&#123;props.author&#125; /&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">          &#123;props<span class="selector-class">.author</span><span class="selector-class">.name</span>&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;<span class="selector-tag">div</span> className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;<span class="selector-tag">div</span> className=<span class="string">"Comment-date"</span>&gt;</span><br><span class="line">        &#123;formatDate(props.date)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提取组件一开始看起来像是一项单调乏味的工作，但是在大型应用中，构建可复用的组件完全必要的。当你的UI中有一部分重复使用了好几次（比如，Button、Panel、Avatar），或者其自身就足够复杂（比如，App、FeedStory、Comment），类似这些都是抽象成一个可复用组件的绝佳选择，这也是一个比较好的做法。</p>
<h2 id="Props的只读性"><a href="#Props的只读性" class="headerlink" title="Props的只读性"></a>Props的只读性</h2><p>无论是使用函数或是类来声明一个组件，它<strong>决不能修改</strong>它自己的props。来看这个sum函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(<span class="selector-tag">a</span>, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于上面的这种函数称为“<strong>纯函数</strong>”，它没有改变它自己的输入值，当传入的值相同时，总是会返回相同的结果。</p>
<p>与之相对的是<strong>非纯函数</strong>，它会改变它自身的输入值：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(account, amount) &#123;</span><br><span class="line">  account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React是非常灵活的，但它也有一个严格的规则：<br><strong>所有的React组件必须像纯函数那样使用它们的props</strong><br>当然，应用的界面是随时间动态变化的，我们将在下一节介绍一种称为“state”的新概念，State可以在不违反上述规则的情况下，根据用户操作、网络响应、或者其他状态变化，使组件动态的响应并改变组件的输出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nisonfuture.cn/2018/03/05/组件 & Props/" data-id="cjelltubc001ci4ugtkm2kpe3" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-事件处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/事件处理/" class="article-date">
  <time datetime="2018-03-05T10:11:39.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/事件处理/">事件处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>React 元素的事件处理和 DOM元素的很相似。但是有一点语法上的不同:</p>
<ul>
<li>React事件绑定属性的命名采用<strong>驼峰式</strong>写法，而不是小写。</li>
<li>如果采用 JSX 的语法你需要传入一个<strong>函数</strong>作为事件处理函数，而不是一个字符串(DOM元素的写法)</li>
</ul>
<p>例如，传统的 HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"activateLasers()"</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>React 中稍稍有点不同：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;activateLasers&#125;</span>&gt;</span>//传递的是一个函数 </span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault。例如，传统的 HTML 中阻止链接默认打开一个新页面，你可以这样写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span></span><br><span class="line">  Click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 React，应该这样来写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The link was clicked.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在这里，e 是一个<strong>合成事件</strong>。React 根据<a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener"> W3C spec</a> 来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。查看 <a href="https://doc.react-china.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent </a>参考指南来了解更多。</p>
<blockquote>
<p>关于阻止默认行为的说明：<br>默认行为就像点击a标签就跳转 阻止了就不会跳转</p>
<ul>
<li>a链接的跳转</li>
<li>单选框、复选框的选中和取消选中</li>
<li>submit的表单提交</li>
</ul>
</blockquote>
<p>使用 React 的时候通常你不需要使用 addEventListener 为一个已创建的 DOM 元素添加监听器。你仅仅需要在这个元素初始渲染的时候提供一个监听器。</p>
<p>当你使用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法。例如，下面的 Toggle 组件渲染一个让用户切换开关状态的按钮：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This binding is necessary to make `this` work in the callback</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="string">'ON'</span> : <span class="string">'OFF'</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;Toggle /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>你必须谨慎对待 JSX 回调函数中的 this，<strong>类的方法默认是不会绑定 this</strong>的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。</p>
<p>这并不是 React 的特殊行为；它是函数如何在 JavaScript 中运行的一部分。通常情况下，如果你<strong>没有在方法后面添加 ()</strong> ，例如 onClick={this.handleClick}，你应该为这个方法<strong>绑定 this</strong>.</p>
<p>如果使用 bind 让你很困惑，这里有两种方式可以解决。如果你正在使用实验性的<strong>属性初始化器语法</strong>，你可以使用<strong>属性初始化器</strong>来正确的绑定回调函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This syntax ensures `this` is bound within handleClick.</span></span><br><span class="line">  <span class="comment">// Warning: this is *experimental* syntax.</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个语法在 Create React App 中默认开启。</p>
<p>如果你没有使用属性初始化器语法，你可以在<strong>回调函数中使用箭头函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&apos;this is:&apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // This syntax ensures `this` is bound within handleClick</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个语法有个问题就是每次 LoggingButton 渲染的时候都会创建一个<strong>不同的回调函数</strong>。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。我们通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。</p>
<h2 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h2><p>通常我们会为事件处理程序传递额外的参数。例如，若是 id 是一个<strong>内联 id</strong>，以下两种方式都可以向事件处理程序传递参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>上述两种方式是等价的，分别通过 arrow functions 和 Function.prototype.bind 来为特定事件类型添加事件处理程序。</p>
<p>上面两个例子中，参数 e 作为 React 事件对象将会被作为第二个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<p>值得注意的是，通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Popper extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.state = &#123;name:&apos;Hello world!&apos;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    preventPop(name, e)&#123;    //事件对象e要放在最后</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;hello&lt;/p&gt;</span><br><span class="line">                &#123;/* Pass params via bind() method. */&#125;</span><br><span class="line">                &lt;a href=&quot;https://reactjs.org&quot; onClick=&#123;this.preventPop.bind(this,this.state.name)&#125;&gt;Click&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nisonfuture.cn/2018/03/05/事件处理/" data-id="cjelltuau000fi4ugntfksj6b" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-表单" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/表单/" class="article-date">
  <time datetime="2018-03-05T10:11:32.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/表单/">表单</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTML表单元素与React中的其他DOM元素有所不同,因为表单元素生来就保留一些内部状态。例如，下面这个表单只接受一个唯一的name。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;label&gt;</span><br><span class="line">    Name:</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;</span><br><span class="line">  &lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>当用户提交表单时，HTML的默认行为会使这个表单跳转到一个新页面。在React中亦是如此。但大多数情况下，我们都会构造一个处理提交表单并可访问用户输入表单数据的函数。实现这一点的标准方法是使用一种称为“受控组件”的技术。</p>
<h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><p>在HTML当中，像\<input>,\<textarea>, 和 \</textarea><select>这类表单元素会维持自身状态，并根据用户输入进行更新。但在React中，可变的状态通常保存在组件的状态属性中，并且只能用 <strong>setState()</strong>. 方法进行更新.</select></p>
<p>我们通过使react变成一种单一数据源的状态来结合二者。React负责渲染表单的组件仍然控制用户后续输入时所发生的变化。相应的，其值由React控制的输入表单元素称为“受控组件”。</p>
<p>例如，我们想要使上个例子中在提交表单时输出name,我们可以写成“受控组件”的形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">lass NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &apos;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;A name was submitted: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 value 属性是在我们的表单元素上设置的，因此显示的值将始终为 React数据源上this.state.value 的值。由于<strong>每次按键都会触发 handleChange</strong> 来更新当前React的state，所展示的值也会随着不同用户的输入而更新。</p>
<p>使用”受控组件”,每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。例如，我们如果想限制输入全部是大写字母，我们可以将handleChange 写为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange(event) &#123;</span><br><span class="line">  this.setState(&#123;value: event.target.value.toUpperCase()&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="textarea标签"><a href="#textarea标签" class="headerlink" title="textarea标签"></a>textarea标签</h2><p>在HTML当中，\<textarea> 元素通过子节点来定义它的文本内容</textarea></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea&gt;</span><br><span class="line">  Hello there, this is some text in a text area</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>
<p>在React中，\<textarea>会用value属性来代替。这样的话，表单中的\</textarea><textarea> 非常类似于使用单行输入的表单：</textarea></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class EssayForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;Please write an essay about your favorite DOM element.&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;An essay was submitted: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意this.state.value是在构造函数中初始化，这样文本区域就能获取到其中的文本。</p>
<h2 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h2><p>在HTML当中，\<select>会创建一个下拉列表。例如这个HTML就创建了一个下拉列表的原型。</select></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt;</span><br><span class="line">  &lt;option selected value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>请注意，Coconut选项最初由于selected属性是被选中的。在React中，并不使用之前的selected属性，而在根select标签上用value属性来表示选中项。这在受控组件中更为方便，因为你只需要在一个地方来更新组件。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class FlavorForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &apos;coconut&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;Your favorite flavor is: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Pick your favorite La Croix flavor:</span><br><span class="line">          &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt;</span><br><span class="line">            &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt;</span><br><span class="line">          &lt;/select&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，<input type="text">,\<textarea>, 和 \</textarea><select> 都十分类似 - 他们都通过传入一个value属性来实现对组件的控制。</select></p>
<h2 id="多个输入的解决方法"><a href="#多个输入的解决方法" class="headerlink" title="多个输入的解决方法"></a>多个输入的解决方法</h2><p>当你有处理多个受控的input元素时，你可以通过给每个元素添加一个name属性，来让处理函数根据 event.target.name的值来选择做什么。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Reservation extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      isGoing: true,</span><br><span class="line">      numberOfGuests: 2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handleInputChange = this.handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    const target = event.target;</span><br><span class="line">    const value = target.type === &apos;checkbox&apos; ? target.checked : target.value;</span><br><span class="line">    const name = target.name;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Is going:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=&quot;isGoing&quot;</span><br><span class="line">            type=&quot;checkbox&quot;</span><br><span class="line">            checked=&#123;this.state.isGoing&#125;</span><br><span class="line">            onChange=&#123;this.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Number of guests:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=&quot;numberOfGuests&quot;</span><br><span class="line">            type=&quot;number&quot;</span><br><span class="line">            value=&#123;this.state.numberOfGuests&#125;</span><br><span class="line">            onChange=&#123;this.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意我们如何使用ES6当中的计算属性名语法来更新与给定输入名称相对应的状态键：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">  [name]: value</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>相当于如下ES5语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var partialState = &#123;&#125;;</span><br><span class="line">partialState[name] = value;</span><br><span class="line">this.setState(partialState);</span><br></pre></td></tr></table></figure>
<p>同样由于 setState() 自动将部分状态合并到当前状态，因此我们只需要使用发生变化的部分调用它。</p>
<h2 id="受控组件的替代方法"><a href="#受控组件的替代方法" class="headerlink" title="受控组件的替代方法"></a>受控组件的替代方法</h2><p>有时使用受控组件可能很繁琐，因为您要为数据可能发生变化的每一种方式都编写一个事件处理程序，并通过一个组件来管理全部的状态。当您将预先存在的代码库转换为React或将React应用程序与非React库集成时，这可能变得特别烦人。在以上情况下，你或许应该看看<a href="https://doc.react-china.org/docs/uncontrolled-components.html" target="_blank" rel="noopener">非受控组件</a>，这是一种表单的替代技术。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nisonfuture.cn/2018/03/05/表单/" data-id="cjelltube001gi4ugw3hrl7ih" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-模板" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/模板/" class="article-date">
  <time datetime="2018-03-04T12:35:59.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/模板/">模板</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>### </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nisonfuture.cn/2018/03/04/模板/" data-id="cjelltub90016i4ugb8zoshty" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-路由跳转问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/路由跳转问题/" class="article-date">
  <time datetime="2018-03-04T12:35:59.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/路由跳转问题/">路由跳转问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="观察路由跳转，我发现是通过"><a href="#观察路由跳转，我发现是通过" class="headerlink" title="观察路由跳转，我发现是通过"></a>观察路由跳转，我发现是通过</h3><p><code>yield put(routerRedux.push(&#39;/dashboard/analysis&#39;));</code><br>这行代码来进行跳转，但是却跳不过去<br>好像触发了路由守卫，没有身份验证成功 所以跳不过去 ，<br>找到一个 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;AuthorizedRoute</span><br><span class="line">           path=&quot;/&quot;</span><br><span class="line">           render=&#123;props =&gt; &lt;BasicLayout &#123;...props&#125; /&gt;&#125;</span><br><span class="line">           authority=&#123;[&apos;admin&apos;, &apos;user&apos;]&#125;</span><br><span class="line">           redirectPath=&quot;/user/login&quot;</span><br><span class="line">         /&gt;</span><br></pre></td></tr></table></figure>
<p><img src="blob:http://markdown.xiaoshujiang.com/9b87a59c-9aa1-48c5-a370-dfd757a3869e" alt="img"></p>
<p>通过看连接 发现 这个被我nginx反向代理向公司服务器转发了 。。。。。。好无语</p>
<p>就算将nginx 的配置只转发 登录的接口 但是 在获取数据的时候回出现问题，有两个请求得不到数据，我手动构造了数据之后就可以正常返回 </p>
<p>D:\luwei\project\wallpaper\wallpaper\src\models\user.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const response = &#123;</span><br><span class="line">  name: &apos;Serati Ma&apos;,</span><br><span class="line">  avatar: &apos;https://gw.alipayobjects.com/zos/rmsportal/BiazfanxmamNRoxxVxka.png&apos;,</span><br><span class="line">  userid: &apos;00000001&apos;,</span><br><span class="line">  notifyCount: 12,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>D:\luwei\project\wallpaper\wallpaper\src\services\api.js<br> 修改返回结果就好 太长就放在最后面了</p>
<p> 所以修改状态是可以的 路由跳转也是可以的 只是之前路由跳转发生错误就返回到原先的路由中<br> 接下来 构建管理端的页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export async function fakeChartData() &#123;</span><br><span class="line">  return &#123;&quot;visitData&quot;:[&#123;&quot;x&quot;:&quot;2018-03-08&quot;,&quot;y&quot;:7&#125;,&#123;&quot;x&quot;:&quot;2018-03-09&quot;,&quot;y&quot;:5&#125;,&#123;&quot;x&quot;:&quot;2018-03-10&quot;,&quot;y&quot;:4&#125;,&#123;&quot;x&quot;:&quot;2018-03-11&quot;,&quot;y&quot;:2&#125;,&#123;&quot;x&quot;:&quot;2018-03-12&quot;,&quot;y&quot;:4&#125;,&#123;&quot;x&quot;:&quot;2018-03-13&quot;,&quot;y&quot;:7&#125;,&#123;&quot;x&quot;:&quot;2018-03-14&quot;,&quot;y&quot;:5&#125;,&#123;&quot;x&quot;:&quot;2018-03-15&quot;,&quot;y&quot;:6&#125;,&#123;&quot;x&quot;:&quot;2018-03-16&quot;,&quot;y&quot;:5&#125;,&#123;&quot;x&quot;:&quot;2018-03-17&quot;,&quot;y&quot;:9&#125;,&#123;&quot;x&quot;:&quot;2018-03-18&quot;,&quot;y&quot;:6&#125;,&#123;&quot;x&quot;:&quot;2018-03-19&quot;,&quot;y&quot;:3&#125;,&#123;&quot;x&quot;:&quot;2018-03-20&quot;,&quot;y&quot;:1&#125;,&#123;&quot;x&quot;:&quot;2018-03-21&quot;,&quot;y&quot;:5&#125;,&#123;&quot;x&quot;:&quot;2018-03-22&quot;,&quot;y&quot;:3&#125;,&#123;&quot;x&quot;:&quot;2018-03-23&quot;,&quot;y&quot;:6&#125;,&#123;&quot;x&quot;:&quot;2018-03-24&quot;,&quot;y&quot;:5&#125;],&quot;visitData2&quot;:[&#123;&quot;x&quot;:&quot;2018-03-08&quot;,&quot;y&quot;:1&#125;,&#123;&quot;x&quot;:&quot;2018-03-09&quot;,&quot;y&quot;:6&#125;,&#123;&quot;x&quot;:&quot;2018-03-10&quot;,&quot;y&quot;:4&#125;,&#123;&quot;x&quot;:&quot;2018-03-11&quot;,&quot;y&quot;:8&#125;,&#123;&quot;x&quot;:&quot;2018-03-12&quot;,&quot;y&quot;:3&#125;,&#123;&quot;x&quot;:&quot;2018-03-13&quot;,&quot;y&quot;:7&#125;,&#123;&quot;x&quot;:&quot;2018-03-14&quot;,&quot;y&quot;:2&#125;],&quot;salesData&quot;:[&#123;&quot;x&quot;:&quot;1月&quot;,&quot;y&quot;:881&#125;,&#123;&quot;x&quot;:&quot;2月&quot;,&quot;y&quot;:345&#125;,&#123;&quot;x&quot;:&quot;3月&quot;,&quot;y&quot;:707&#125;,&#123;&quot;x&quot;:&quot;4月&quot;,&quot;y&quot;:1191&#125;,&#123;&quot;x&quot;:&quot;5月&quot;,&quot;y&quot;:976&#125;,&#123;&quot;x&quot;:&quot;6月&quot;,&quot;y&quot;:1020&#125;,&#123;&quot;x&quot;:&quot;7月&quot;,&quot;y&quot;:1088&#125;,&#123;&quot;x&quot;:&quot;8月&quot;,&quot;y&quot;:227&#125;,&#123;&quot;x&quot;:&quot;9月&quot;,&quot;y&quot;:699&#125;,&#123;&quot;x&quot;:&quot;10月&quot;,&quot;y&quot;:570&#125;,&#123;&quot;x&quot;:&quot;11月&quot;,&quot;y&quot;:852&#125;,&#123;&quot;x&quot;:&quot;12月&quot;,&quot;y&quot;:617&#125;],&quot;searchData&quot;:[&#123;&quot;index&quot;:1,&quot;keyword&quot;:&quot;搜索关键词-0&quot;,&quot;count&quot;:924,&quot;range&quot;:48,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:2,&quot;keyword&quot;:&quot;搜索关键词-1&quot;,&quot;count&quot;:840,&quot;range&quot;:28,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:3,&quot;keyword&quot;:&quot;搜索关键词-2&quot;,&quot;count&quot;:177,&quot;range&quot;:65,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:4,&quot;keyword&quot;:&quot;搜索关键词-3&quot;,&quot;count&quot;:886,&quot;range&quot;:83,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:5,&quot;keyword&quot;:&quot;搜索关键词-4&quot;,&quot;count&quot;:866,&quot;range&quot;:3,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:6,&quot;keyword&quot;:&quot;搜索关键词-5&quot;,&quot;count&quot;:671,&quot;range&quot;:15,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:7,&quot;keyword&quot;:&quot;搜索关键词-6&quot;,&quot;count&quot;:98,&quot;range&quot;:65,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:8,&quot;keyword&quot;:&quot;搜索关键词-7&quot;,&quot;count&quot;:793,&quot;range&quot;:49,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:9,&quot;keyword&quot;:&quot;搜索关键词-8&quot;,&quot;count&quot;:1,&quot;range&quot;:40,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:10,&quot;keyword&quot;:&quot;搜索关键词-9&quot;,&quot;count&quot;:811,&quot;range&quot;:15,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:11,&quot;keyword&quot;:&quot;搜索关键词-10&quot;,&quot;count&quot;:695,&quot;range&quot;:3,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:12,&quot;keyword&quot;:&quot;搜索关键词-11&quot;,&quot;count&quot;:78,&quot;range&quot;:50,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:13,&quot;keyword&quot;:&quot;搜索关键词-12&quot;,&quot;count&quot;:849,&quot;range&quot;:75,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:14,&quot;keyword&quot;:&quot;搜索关键词-13&quot;,&quot;count&quot;:646,&quot;range&quot;:90,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:15,&quot;keyword&quot;:&quot;搜索关键词-14&quot;,&quot;count&quot;:78,&quot;range&quot;:63,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:16,&quot;keyword&quot;:&quot;搜索关键词-15&quot;,&quot;count&quot;:553,&quot;range&quot;:6,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:17,&quot;keyword&quot;:&quot;搜索关键词-16&quot;,&quot;count&quot;:263,&quot;range&quot;:12,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:18,&quot;keyword&quot;:&quot;搜索关键词-17&quot;,&quot;count&quot;:742,&quot;range&quot;:25,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:19,&quot;keyword&quot;:&quot;搜索关键词-18&quot;,&quot;count&quot;:724,&quot;range&quot;:33,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:20,&quot;keyword&quot;:&quot;搜索关键词-19&quot;,&quot;count&quot;:705,&quot;range&quot;:76,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:21,&quot;keyword&quot;:&quot;搜索关键词-20&quot;,&quot;count&quot;:27,&quot;range&quot;:9,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:22,&quot;keyword&quot;:&quot;搜索关键词-21&quot;,&quot;count&quot;:967,&quot;range&quot;:85,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:23,&quot;keyword&quot;:&quot;搜索关键词-22&quot;,&quot;count&quot;:516,&quot;range&quot;:52,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:24,&quot;keyword&quot;:&quot;搜索关键词-23&quot;,&quot;count&quot;:541,&quot;range&quot;:15,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:25,&quot;keyword&quot;:&quot;搜索关键词-24&quot;,&quot;count&quot;:96,&quot;range&quot;:57,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:26,&quot;keyword&quot;:&quot;搜索关键词-25&quot;,&quot;count&quot;:829,&quot;range&quot;:60,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:27,&quot;keyword&quot;:&quot;搜索关键词-26&quot;,&quot;count&quot;:87,&quot;range&quot;:22,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:28,&quot;keyword&quot;:&quot;搜索关键词-27&quot;,&quot;count&quot;:237,&quot;range&quot;:81,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:29,&quot;keyword&quot;:&quot;搜索关键词-28&quot;,&quot;count&quot;:873,&quot;range&quot;:12,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:30,&quot;keyword&quot;:&quot;搜索关键词-29&quot;,&quot;count&quot;:711,&quot;range&quot;:31,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:31,&quot;keyword&quot;:&quot;搜索关键词-30&quot;,&quot;count&quot;:239,&quot;range&quot;:32,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:32,&quot;keyword&quot;:&quot;搜索关键词-31&quot;,&quot;count&quot;:428,&quot;range&quot;:58,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:33,&quot;keyword&quot;:&quot;搜索关键词-32&quot;,&quot;count&quot;:307,&quot;range&quot;:22,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:34,&quot;keyword&quot;:&quot;搜索关键词-33&quot;,&quot;count&quot;:192,&quot;range&quot;:13,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:35,&quot;keyword&quot;:&quot;搜索关键词-34&quot;,&quot;count&quot;:557,&quot;range&quot;:1,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:36,&quot;keyword&quot;:&quot;搜索关键词-35&quot;,&quot;count&quot;:696,&quot;range&quot;:43,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:37,&quot;keyword&quot;:&quot;搜索关键词-36&quot;,&quot;count&quot;:85,&quot;range&quot;:89,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:38,&quot;keyword&quot;:&quot;搜索关键词-37&quot;,&quot;count&quot;:395,&quot;range&quot;:70,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:39,&quot;keyword&quot;:&quot;搜索关键词-38&quot;,&quot;count&quot;:111,&quot;range&quot;:23,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:40,&quot;keyword&quot;:&quot;搜索关键词-39&quot;,&quot;count&quot;:55,&quot;range&quot;:22,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:41,&quot;keyword&quot;:&quot;搜索关键词-40&quot;,&quot;count&quot;:242,&quot;range&quot;:35,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:42,&quot;keyword&quot;:&quot;搜索关键词-41&quot;,&quot;count&quot;:969,&quot;range&quot;:77,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:43,&quot;keyword&quot;:&quot;搜索关键词-42&quot;,&quot;count&quot;:169,&quot;range&quot;:95,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:44,&quot;keyword&quot;:&quot;搜索关键词-43&quot;,&quot;count&quot;:542,&quot;range&quot;:44,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:45,&quot;keyword&quot;:&quot;搜索关键词-44&quot;,&quot;count&quot;:184,&quot;range&quot;:4,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:46,&quot;keyword&quot;:&quot;搜索关键词-45&quot;,&quot;count&quot;:51,&quot;range&quot;:33,&quot;status&quot;:0&#125;,&#123;&quot;index&quot;:47,&quot;keyword&quot;:&quot;搜索关键词-46&quot;,&quot;count&quot;:575,&quot;range&quot;:73,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:48,&quot;keyword&quot;:&quot;搜索关键词-47&quot;,&quot;count&quot;:317,&quot;range&quot;:36,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:49,&quot;keyword&quot;:&quot;搜索关键词-48&quot;,&quot;count&quot;:491,&quot;range&quot;:95,&quot;status&quot;:1&#125;,&#123;&quot;index&quot;:50,&quot;keyword&quot;:&quot;搜索关键词-49&quot;,&quot;count&quot;:702,&quot;range&quot;:53,&quot;status&quot;:0&#125;],&quot;offlineData&quot;:[&#123;&quot;name&quot;:&quot;门店0&quot;,&quot;cvr&quot;:0.6&#125;,&#123;&quot;name&quot;:&quot;门店1&quot;,&quot;cvr&quot;:0.3&#125;,&#123;&quot;name&quot;:&quot;门店2&quot;,&quot;cvr&quot;:0.8&#125;,&#123;&quot;name&quot;:&quot;门店3&quot;,&quot;cvr&quot;:0.5&#125;,&#123;&quot;name&quot;:&quot;门店4&quot;,&quot;cvr&quot;:0.1&#125;,&#123;&quot;name&quot;:&quot;门店5&quot;,&quot;cvr&quot;:0.5&#125;,&#123;&quot;name&quot;:&quot;门店6&quot;,&quot;cvr&quot;:0.4&#125;,&#123;&quot;name&quot;:&quot;门店7&quot;,&quot;cvr&quot;:0.9&#125;,&#123;&quot;name&quot;:&quot;门店8&quot;,&quot;cvr&quot;:0.6&#125;,&#123;&quot;name&quot;:&quot;门店9&quot;,&quot;cvr&quot;:0.1&#125;],&quot;offlineChartData&quot;:[&#123;&quot;x&quot;:1520475334315,&quot;y1&quot;:62,&quot;y2&quot;:81&#125;,&#123;&quot;x&quot;:1520477134315,&quot;y1&quot;:29,&quot;y2&quot;:93&#125;,&#123;&quot;x&quot;:1520478934315,&quot;y1&quot;:53,&quot;y2&quot;:13&#125;,&#123;&quot;x&quot;:1520480734315,&quot;y1&quot;:96,&quot;y2&quot;:81&#125;,&#123;&quot;x&quot;:1520482534315,&quot;y1&quot;:59,&quot;y2&quot;:89&#125;,&#123;&quot;x&quot;:1520484334315,&quot;y1&quot;:70,&quot;y2&quot;:43&#125;,&#123;&quot;x&quot;:1520486134315,&quot;y1&quot;:72,&quot;y2&quot;:107&#125;,&#123;&quot;x&quot;:1520487934315,&quot;y1&quot;:91,&quot;y2&quot;:28&#125;,&#123;&quot;x&quot;:1520489734315,&quot;y1&quot;:74,&quot;y2&quot;:32&#125;,&#123;&quot;x&quot;:1520491534315,&quot;y1&quot;:61,&quot;y2&quot;:37&#125;,&#123;&quot;x&quot;:1520493334315,&quot;y1&quot;:60,&quot;y2&quot;:53&#125;,&#123;&quot;x&quot;:1520495134315,&quot;y1&quot;:86,&quot;y2&quot;:66&#125;,&#123;&quot;x&quot;:1520496934315,&quot;y1&quot;:96,&quot;y2&quot;:67&#125;,&#123;&quot;x&quot;:1520498734315,&quot;y1&quot;:83,&quot;y2&quot;:89&#125;,&#123;&quot;x&quot;:1520500534315,&quot;y1&quot;:25,&quot;y2&quot;:70&#125;,&#123;&quot;x&quot;:1520502334315,&quot;y1&quot;:10,&quot;y2&quot;:14&#125;,&#123;&quot;x&quot;:1520504134315,&quot;y1&quot;:42,&quot;y2&quot;:36&#125;,&#123;&quot;x&quot;:1520505934315,&quot;y1&quot;:31,&quot;y2&quot;:48&#125;,&#123;&quot;x&quot;:1520507734315,&quot;y1&quot;:40,&quot;y2&quot;:81&#125;,&#123;&quot;x&quot;:1520509534315,&quot;y1&quot;:78,&quot;y2&quot;:37&#125;],&quot;salesTypeData&quot;:[&#123;&quot;x&quot;:&quot;家用电器&quot;,&quot;y&quot;:4544&#125;,&#123;&quot;x&quot;:&quot;食用酒水&quot;,&quot;y&quot;:3321&#125;,&#123;&quot;x&quot;:&quot;个护健康&quot;,&quot;y&quot;:3113&#125;,&#123;&quot;x&quot;:&quot;服饰箱包&quot;,&quot;y&quot;:2341&#125;,&#123;&quot;x&quot;:&quot;母婴产品&quot;,&quot;y&quot;:1231&#125;,&#123;&quot;x&quot;:&quot;其他&quot;,&quot;y&quot;:1231&#125;],&quot;salesTypeDataOnline&quot;:[&#123;&quot;x&quot;:&quot;家用电器&quot;,&quot;y&quot;:244&#125;,&#123;&quot;x&quot;:&quot;食用酒水&quot;,&quot;y&quot;:321&#125;,&#123;&quot;x&quot;:&quot;个护健康&quot;,&quot;y&quot;:311&#125;,&#123;&quot;x&quot;:&quot;服饰箱包&quot;,&quot;y&quot;:41&#125;,&#123;&quot;x&quot;:&quot;母婴产品&quot;,&quot;y&quot;:121&#125;,&#123;&quot;x&quot;:&quot;其他&quot;,&quot;y&quot;:111&#125;],&quot;salesTypeDataOffline&quot;:[&#123;&quot;x&quot;:&quot;家用电器&quot;,&quot;y&quot;:99&#125;,&#123;&quot;x&quot;:&quot;个护健康&quot;,&quot;y&quot;:188&#125;,&#123;&quot;x&quot;:&quot;服饰箱包&quot;,&quot;y&quot;:344&#125;,&#123;&quot;x&quot;:&quot;母婴产品&quot;,&quot;y&quot;:255&#125;,&#123;&quot;x&quot;:&quot;其他&quot;,&quot;y&quot;:65&#125;],&quot;radarData&quot;:[&#123;&quot;name&quot;:&quot;个人&quot;,&quot;label&quot;:&quot;引用&quot;,&quot;value&quot;:10&#125;,&#123;&quot;name&quot;:&quot;个人&quot;,&quot;label&quot;:&quot;口碑&quot;,&quot;value&quot;:8&#125;,&#123;&quot;name&quot;:&quot;个人&quot;,&quot;label&quot;:&quot;产量&quot;,&quot;value&quot;:4&#125;,&#123;&quot;name&quot;:&quot;个人&quot;,&quot;label&quot;:&quot;贡献&quot;,&quot;value&quot;:5&#125;,&#123;&quot;name&quot;:&quot;个人&quot;,&quot;label&quot;:&quot;热度&quot;,&quot;value&quot;:7&#125;,&#123;&quot;name&quot;:&quot;团队&quot;,&quot;label&quot;:&quot;引用&quot;,&quot;value&quot;:3&#125;,&#123;&quot;name&quot;:&quot;团队&quot;,&quot;label&quot;:&quot;口碑&quot;,&quot;value&quot;:9&#125;,&#123;&quot;name&quot;:&quot;团队&quot;,&quot;label&quot;:&quot;产量&quot;,&quot;value&quot;:6&#125;,&#123;&quot;name&quot;:&quot;团队&quot;,&quot;label&quot;:&quot;贡献&quot;,&quot;value&quot;:3&#125;,&#123;&quot;name&quot;:&quot;团队&quot;,&quot;label&quot;:&quot;热度&quot;,&quot;value&quot;:1&#125;,&#123;&quot;name&quot;:&quot;部门&quot;,&quot;label&quot;:&quot;引用&quot;,&quot;value&quot;:4&#125;,&#123;&quot;name&quot;:&quot;部门&quot;,&quot;label&quot;:&quot;口碑&quot;,&quot;value&quot;:1&#125;,&#123;&quot;name&quot;:&quot;部门&quot;,&quot;label&quot;:&quot;产量&quot;,&quot;value&quot;:6&#125;,&#123;&quot;name&quot;:&quot;部门&quot;,&quot;label&quot;:&quot;贡献&quot;,&quot;value&quot;:5&#125;,&#123;&quot;name&quot;:&quot;部门&quot;,&quot;label&quot;:&quot;热度&quot;,&quot;value&quot;:7&#125;]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nisonfuture.cn/2018/03/04/路由跳转问题/" data-id="cjelltubf001ji4ugrk0j70tu" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/programming/">编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ant-Design/">ant Design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js工具/">js工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ant-Design/" style="font-size: 16.67px;">ant Design</a> <a href="/tags/js工具/" style="font-size: 10px;">js工具</a> <a href="/tags/react/" style="font-size: 20px;">react</a> <a href="/tags/工具/" style="font-size: 13.33px;">工具</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/11/marjs随机生成hash值/">js随机生成hash值</a>
          </li>
        
          <li>
            <a href="/2018/03/08/查看列表组件/">查看列表组件</a>
          </li>
        
          <li>
            <a href="/2018/03/08/昨天loading状态的修改问题/">昨天loading状态的修改问题</a>
          </li>
        
          <li>
            <a href="/2018/03/06/github仓库配置/">github仓库配置</a>
          </li>
        
          <li>
            <a href="/2018/03/06/ant Design 路由/">ant Design 路由</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Pling Huang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>